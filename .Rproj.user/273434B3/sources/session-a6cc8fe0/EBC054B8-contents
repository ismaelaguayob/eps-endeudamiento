---
title: "Procesamieto"
format: html
editor: visual
---

# Procesamiento

## Evaluación docente

### Primero cargamos los datos:

```{r}
options(scipen = 999) # para desactivar notacion cientifica
rm(list = ls()) # para limpiar el entorno de trabajo
pacman::p_load(readxl,
               dplyr,
               tidyverse,
               haven)
```

```{r}

datos_ed <- read_xlsx("eval_docente2023/eval_docente2.xlsx")
#("eval_docente.xlsx")
```

```{r}

datos_ed <- datos_ed %>% 
  select(
    año=AGNO_EVAL,
    nombre_est=NOM_RBD,
    cod_reg=NOM_REG_RBD_A,
    cod_com=NOM_COM_RBD,
    dependencia=COD_DEPE2,
    nivel=NIVEL,
    rural=RURAL_RBD,
    MRUN,
    sexo=DOC_GENERO,
    fecha_nacimiento=DOC_FEC_NAC,
    pj=PF_PJE,
    letra_pj=PF_CAT_CARRERA
)
```

Los datos no parecen tener NAs. Se cambiaron los nombres de las variables para mayor comprensión.

### Agregamos las labels para el análisis

```{r}
library(haven)
library(dplyr)
library(labelled) # Importante: Cargar el paquete labelled

# Suponiendo que tus datos están en un dataframe llamado 'datos'
# y ya has renombrado las columnas como se muestra en tu código.

datos_ed <- datos_ed %>%
  set_variable_labels( # Ahora funciona porque viene de labelled
    año = "Año evaluación",
    nombre_est = "Nombre establecimiento",
    cod_reg = "Nombre de la región del establecimiento abreviada",
    cod_com = "Nombre oficial de la comuna en que se ubica el establecimiento",
    dependencia = "Dependencia del establecimiento (abreviada)",
    nivel = "Nivel de educación del establecimiento",
    rural = "Condición rural o urbana del establecimiento (0: Urbano, 1: Rural)",
    MRUN = "Identificador numérico único del docente",
    sexo = "Sexo del docente evaluado",
    fecha_nacimiento = "Fecha de nacimiento del Docente (AAAAMM)",
    letra_pj = "Categoría portafolio (A - D)",
    pj = "Puntaje Portafolio"
  )

# Asignar labels de variable
datos_ed <- datos_ed %>%
  set_variable_labels(
    dependencia = "Dependencia del establecimiento (abreviada)",
    rural = "Condición rural o urbana del establecimiento (0: Urbano, 1: Rural)",
    sexo = "Sexo del docente evaluado",
    nivel = "Nivel del docente" # o el label que corresponda
  )

# Crear nuevas columnas con los labels asignados
datos_ed <- datos_ed %>%
  mutate(
    dependencia_labelled = labelled(dependencia, labels = c(
      "Municipal" = 1,
      "Particular Subvencionado" = 2,
      "Particular Pagado" = 3,
      "Corporación de Administración delegada" = 4,
      "Servicio Local de Educación" = 5,
      "JUNJI" = 6,
      "INTEGRA" = 7
    )),
    rural_labelled = labelled(rural, labels = c(
      "Urbano" = 0,
      "Rural" = 1
    )),
    sexo_labelled = labelled(sexo, labels = c(
      "Hombre" = 1,
      "Mujer" = 2
    )),
    nivel_labelled = labelled(nivel, labels=c(
      "Enseñanza Técnico Profesional" = "EMTP",
      "Enzeñanza Media" = "EM",
      "Enzeñanza Básica" = "EB",
      "Educación Parvularia" = "EP",
      "Educación Especial Necesiadades Educativas Permanentes" = "EENEEP",
      "Educación Especial" = "EE",
      "Programa de Habilitación Psicológica"= "PH",
      "Servicios Lengua Indígena" = "SLI",
      "Educación de Adultos" = "EA",
      "Educación en Contexto de Encierro" = "ECE"
    )),
    reg_labelled = labelled(cod_reg, labels=c(
      "Región Metropolitana" = "RM",
      "Región de Valparaiso" = "VALPO",
      "Región de Coquimbo" = "COQ",
      "Región de Arica y Parinacota" = "AYP",
      "Región de Tarapacá" = "TPCA",
      "Región de Antofagasta" = "ANTOF",
      "Región de Atacama" = "ATCMA",
      "Región del Maule" = "MAULE",
      "Región del BioBío" = "BBIO",
      "Región de Ñuble" = "NUBLE",
      "Región de la Araucanía" = "ARAUC",
      "Región de los Lagos" = "LAGOS",
      "Región de los Ríos" = "RIOS",
      "Región de Aysén ..." = "AYSEN",
      "Región de Magallanes y la Antártida" = "MAG",
      "Región de O'Higgins (resumido)" = "LGBO"
    ))
  )


# Reemplazar las columnas originales con las nuevas columnas etiquetadas
datos_ed <- datos_ed %>%
  mutate(
    dependencia = dependencia_labelled,
    rural = rural_labelled,
    sexo = sexo_labelled,
    nivel = nivel_labelled,
    cod_reg = reg_labelled
  ) %>%
  select(-ends_with("_labelled")) # Eliminar las columnas temporales

datos_ed$sexo <- as_factor(datos_ed$sexo)
datos_ed$dependencia <- as_factor(datos_ed$dependencia)
datos_ed$rural <- as_factor(datos_ed$rural)
datos_ed$nivel <- as_factor(datos_ed$nivel)
datos_ed$cod_reg <- as_factor(datos_ed$cod_reg)

# Agregar etiquetas de valor para las variables categóricas
```

### Calculamos la edad a partir del año

```{r}

# Calculo edad

fecha_referencia <- ymd("2023-06-01")  # Definimos la fecha de referencia

datos_ed <- datos_ed %>%
  mutate(fecha_nacimiento = as.character(fecha_nacimiento),
         fecha_nacimiento = ymd(fecha_nacimiento),
         edad = year(fecha_referencia) - year(fecha_nacimiento) -
                  ifelse(month(fecha_referencia)*100 + day(fecha_referencia) < month(fecha_nacimiento)*100 + day(fecha_nacimiento), 1, 0))

# Tramo edad

datos_ed <- datos_ed %>%
  mutate(grupo_edad = cut(edad,
                           breaks = c(19, 29, 39, 49, 59, 69, Inf),
                           labels = c("20-29", "30-39", "40-49", "50-59", "60-69", "70+"),
                           right = TRUE)) # Intervalos (edad <= break]
```

### Corregimos el csv (pj portafolio)

```{r}

datos_ed$pj <- as.numeric(datos_ed$pj)

# Función para corregir un único valor
corregir_puntaje <- function(puntaje) {
  if (is.na(puntaje)) { # Manejar valores NA
    return(NA)
  }
  if (puntaje < 1) {
    return(1.0)  # Limite inferior
  } else if (puntaje > 4) {
    puntaje_corregido <- as.numeric(substr(as.character(puntaje), 1, 1)) +  #Obtengo el primer número
      as.numeric(substr(as.character(puntaje), 2, 2)) / 10  #Obtengo el segundo número y lo divido para que sea decimal
    if(puntaje_corregido > 4){
        return(4.0)
    }
    return(puntaje_corregido)
  } else {
    return(puntaje) # Si está en el rango, no se modifica
  }
}

# Aplica la función a la columna 'pj'
datos_ed$pj <- sapply(datos_ed$pj, corregir_puntaje)

#Imprime los primeros valores de la columna para confirmar el cambio
head(datos_ed$pj)
```

## ECEP y cargo docente

### Cargamos los datos

```{r}

datos_ecep <- read_xlsx("./ecep_2023/ecep_2023_docentes.xlsx")

datos_ecep <- datos_ecep %>% select(MRUN, PTJE_FINAL) 

datos_ecep_ed <- left_join(datos_ed, datos_ecep, by="MRUN")
```

```{r}
datos_cargo_2023 <- read_xlsx("./cargos_docentes_2023/cargo_docente_2023.xlsx")

datos_cargo_2023 <- datos_cargo_2023 %>% select(
  MRUN,
  HORAS_AULA,
  HORAS_CONTRATO,
  ANO_SERVICIO_SISTEMA,
  ID_ITC,
  ID_ITC_CORR
)
```

# Análisis

### Tablas descriptivas

```{r}

tabla_descriptiva <- table1::table1(
  ~sexo + edad + dependencia + edad,
  data=datos_lb,
  caption="Tabla de descriptivos de la muestra"
  
)

tabla_descriptiva2 <- table1::table1(
  ~nivel + rural,
  data=datos_lb,
  caption="Tabla de descriptivos de la muestra"
  
)

tabla_descriptiva3 <- table1::table1(
  ~cod_reg,
  data=datos_lb,
  caption="Tabla de descriptivos de la muestra"
  
)
```

```{r}

tabla_sexo <- table1::table1(
  ~ pj | sexo, 
  data=datos_lb,
  caption = "Tabla 1: blablabla"
  )

tabla_dependencia <- table1::table1(
  ~ pj | dependencia, 
  data=datos_lb,
  caption = "Tabla 1: blablabla"
  )

tabla_rural <- table1::table1(
  ~ pj | rural, 
  data=datos_lb,
  caption = "Tabla 1: blablabla"
  )

tabla_region <- table1::table1(
  ~ pj | cod_reg, 
  data=datos_lb,
  caption = "Tabla 1: blablabla"
  )

tabla_nivel <- table1::table1(
  ~ pj | nivel, 
  data=datos_lb,
  caption = "Tabla 1: blablabla"
  )

tabla_region <- table1::table1(
  ~ pj | cod_reg, 
  data=datos_lb,
  caption = "Tabla 1: blablabla"
  )
```

### Gráficos bivariados

```{r}
# --- Cargar librerías (si no están cargadas) ---
library(dplyr)
library(ggplot2)
library(scales)


# --- PASO 1: Calcular promedio general (sin cambios) ---
overall_avg_pj <- mean(datos_lb$pj, na.rm = TRUE)
print(paste("Promedio general de pj:", round(overall_avg_pj, 2)))

# --- PASO 2: Función MODIFICADA para generar gráficos ---

create_pj_comparison_plot <- function(data, group_var_name, overall_avg) {

  # Asegurarse que la variable de grupo es un factor
  data[[group_var_name]] <- factor(data[[group_var_name]])

  # Calcular promedios por grupo y diferencia porcentual
  summary_data <- data %>%
    group_by(.data[[group_var_name]]) %>%
    summarise(
      avg_pj = mean(pj, na.rm = TRUE),
      n = n(), # Contar observaciones por grupo
      .groups = 'drop'
    ) %>%
    mutate(
      pct_diff = (avg_pj - overall_avg) / overall_avg
    )

  # Crear el gráfico
  plot <- ggplot(summary_data, aes(x = .data[[group_var_name]], y = avg_pj)) +
    geom_col(aes(fill = .data[[group_var_name]]), show.legend = FALSE, alpha = 0.8) +
    geom_hline( # Línea para el promedio general
      yintercept = overall_avg,
      linetype = "dashed",
      color = "darkgrey",
      linewidth = 1
    ) +
    # TEXTO 1: Promedio (2 decimales) y Dif % (SOBRE la barra)
    geom_text(
      aes(label = paste0(sprintf("%.2f", avg_pj), # Formato con 2 decimales
                         "\n(",
                         scales::percent(pct_diff, accuracy = 0.1), # Porcentaje
                         ")")),
      vjust = -0.4, # Ajustar posición vertical sobre la barra
      size = 5
    ) +
    # TEXTO 2: Frecuencia (n) (DENTRO de la barra, cerca de la base)
    geom_text(
      aes(label = paste("n =", n)), # Etiqueta con la frecuencia
      y = 0,          # Posición y inicial cerca de la base
      vjust = -0.6,   # Ajustar para subirla un poco desde y=0
      size = 6,       # Tamaño ligeramente menor
      colour = "black" # Color del texto (ajustar si las barras son muy oscuras)
                      # Podría ser "white" si las barras son oscuras
    ) +
     annotate( # Etiqueta para la línea del promedio general
        "text", x = Inf, y = overall_avg,
        label = paste("Promedio General:", sprintf("%.2f", overall_avg)), # 2 decimales aquí también
        hjust = 1.05, vjust = -0.5, size = 5, color = "black"
     ) +
    # Asegurar que el eje Y empiece en 0 y tenga espacio arriba
    scale_y_continuous(expand = expansion(mult = c(0.01, 0.15)), limits = c(0, NA)) +
    labs(
      title = paste("Diferencia de portafolio por", group_var_name),
      subtitle = "Barras: Promedio. Texto sobre barra: Promedio (Dif % vs General). Texto en barra: Frecuencia (n).",
      x = group_var_name,
      y = "Promedio de portafolio",
      caption = paste("Línea discontinua = Promedio General =", sprintf("%.2f", overall_avg)) # 2 decimales
    ) +
    theme_minimal(base_size = 13) +
    theme(
      plot.title = element_text(face = "bold"),
      axis.text.x = element_text(angle = 45, hjust = 1, size=12),
      plot.caption = element_text(hjust = 0, color = "grey40")
    )

    # Ajuste específico si hay MUCHOS niveles (ej: cod_reg podría tener muchos)
    num_levels <- nlevels(data[[group_var_name]])
    if (num_levels > 8) {
      plot <- plot + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=9))
    }

  return(plot)
}

```

```{r}

# --- PASO 3: Generar los gráficos (sin cambios) ---
variables_independientes <- c("sexo", "dependencia", "rural", "grupo_edad", "nivel")
lista_graficos <- list()
for (variable in variables_independientes) {
  lista_graficos[[variable]] <- create_pj_comparison_plot(
    data = datos_lb,
    group_var_name = variable,
    overall_avg = overall_avg_pj
  )
}

```

```{r}


grafico_nivel <- create_pj_comparison_plot(
  data=datos_lb,
  group_var_name = "nivel",
  overall_avg = overall_avg_pj
)


# Define el ancho deseado para las líneas (ajústalo según necesites)
ancho_etiqueta <- 15 # Número máximo de caracteres por línea (experimenta con este valor)

# Añade la capa de escala para modificar las etiquetas
grafico_nivel <- grafico_nivel +
  scale_x_discrete(
    guide = guide_axis(check.overlap = FALSE), # Puede ayudar, pero str_wrap es mejor
    labels = function(x) str_wrap(x, width = ancho_etiqueta)
  ) +
  # Opcional: Ajustar un poco el tema si las etiquetas de varias líneas chocan
  theme(axis.text.x = element_text(vjust = 0.5, # Ajuste vertical si es necesario
                                   lineheight = 0.9,
                                   size=15)) # Espacio entre líneas

```

#### Gráfico región

```{r}

summary_region <- datos_lb %>%
  # Asegurarse que cod_reg es factor (si no lo es ya)
  mutate(cod_reg = factor(cod_reg)) %>%
  # Agrupar por región
  group_by(cod_reg) %>%
  # Calcular promedio y frecuencia
  summarise(
    avg_pj = mean(pj, na.rm = TRUE),
    n = n(),
    .groups = 'drop'
  ) %>%
  # Calcular diferencia porcentual
  mutate(
    pct_diff = (avg_pj - overall_avg_pj) / overall_avg_pj
  ) %>%
  # ¡IMPORTANTE! Reordenar el factor 'cod_reg' basado en 'avg_pj' (descendente)
  mutate(
    cod_reg_ordered = fct_reorder(cod_reg, avg_pj, .desc = TRUE) # Usar .desc = TRUE para mayor a menor
  )

grafico_region <- ggplot(summary_region,
                                 # Eje Y: Región ordenada. Eje X: Promedio pj
                                 aes(x = avg_pj, y = cod_reg_ordered)) +
  # Barras horizontales
  geom_col(aes(fill = cod_reg_ordered), show.legend = FALSE, alpha = 0.8) +

  # Línea VERTICAL para el promedio general (eje X ahora es el valor)
  geom_vline(
    xintercept = overall_avg_pj,
    linetype = "dashed",
    color = "darkgrey",
    linewidth = 1
  ) +

  # TEXTO 1: Promedio (2 dec) y Dif % (A LA DERECHA de la barra)
  geom_text(
    aes(label = paste0(sprintf("%.2f", avg_pj), # Formato con 2 decimales
                       " (",
                       scales::percent(pct_diff, accuracy = 0.1), # Porcentaje
                       ")")),
    hjust = -0.1, # Ajustar posición horizontal (negativo lo mueve a la derecha)
    size = 3.0    # Ajustar tamaño si es necesario para que quepa
  ) +

  # TEXTO 2: Frecuencia (n) (CERCA DEL EJE Y, dentro de la barra)
  geom_text(
    aes(label = paste("n =", n)),
    x = 0,         # Posición X inicial cerca del eje Y
    hjust = -0.2,  # Ajustar para moverlo a la derecha del eje (dentro de la barra)
    size = 2.8,    # Tamaño ligeramente menor
    colour = "black" # O blanco si las barras son muy oscuras
  ) +

  # Etiqueta para la línea del promedio general
   annotate(
     "text",
     x = overall_avg_pj, y = Inf, # Posicionar en el promedio, arriba del todo
     label = paste("Promedio General:", sprintf("%.2f", overall_avg_pj)),
     hjust = -0.05, vjust = 1.5, # Ajustar para que quede cerca y sobre la línea
     size = 3, color = "darkgrey"
   ) +

  # Expandir eje X para dar espacio a las etiquetas de la derecha
  # Asegurar que empiece cerca de 0
  scale_x_continuous(expand = expansion(mult = c(0.01, 0.18)), limits = c(0, NA)) +

  # Etiquetas y Títulos
  labs(
    title = "Promedio de 'pj' por Región (Ordenado)",
    subtitle = "Barras ordenadas de mayor a menor promedio. Texto indica Promedio (Dif % vs General) y Frecuencia (n).",
    x = "Promedio de 'pj'",
    y = "Región", # El eje Y ahora es la categoría
    caption = paste("Línea discontinua = Promedio General =", sprintf("%.2f", overall_avg_pj))
  ) +

  # Tema
  theme_minimal(base_size = 11) + # Ajustar tamaño base si es necesario
  theme(
    plot.title = element_text(face = "bold"),
    axis.text.y = element_text(size = 9), # Ajustar tamaño de etiquetas de región si son muchas
    plot.caption = element_text(hjust = 0, color = "grey40")
  )
```

### Descarga de gráficos en máxima calidad

```{r}
# --- Cargar ggplot2 si no está cargado ---
library(ggplot2)
library(fs) # Para manejar rutas de archivo de forma más robusta (opcional pero recomendado)

# --- 1. Definir la Carpeta de Destino ---
# Cambia "graficos_output" por el nombre y ruta que prefieras
output_dir <- "graficos_output"

# Crear la carpeta si no existe (de forma segura)
dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)

# --- 2. Iterar y Guardar cada Gráfico ---

# Suponiendo que tu lista se llama 'lista_graficos'
# y los nombres de los elementos son "sexo", "dependencia", etc.

# Opciones comunes de configuración para ggsave:
save_width <- 16  # Ancho en pulgadas (ajusta según necesites)
save_height <- 9 # Alto en pulgadas (ajusta según necesites)
save_units <- "in" # Unidades: "in", "cm", "mm"
save_dpi <- 600 # Resolución para PNG/TIFF (300=buena, 600=excelente)


# --- Opción B: Guardar como PNG (Rasterizado - Alta Resolución) ---
for (plot_name in names(lista_graficos)) {
  current_plot <- lista_graficos[[plot_name]]
  file_name <- fs::path(output_dir, paste0("grafico_", plot_name, "_alta_calidad.png")) # Extensión .png

  ggsave(
    filename = file_name,
    plot = current_plot,
    device = "png", # Especifica el dispositivo PNG
    width = save_width,
    height = save_height,
    units = save_units,
    dpi = save_dpi, # ¡Importante para la calidad del PNG! (usa 300 o 600)
    bg = "white" # Opcional: definir color de fondo si hay transparencia
  )
  print(paste("Guardado:", file_name))
}

ggsave(
    filename = "./graficos_output/grafico_nivel_alta_calidad.png",
    plot = grafico_nivel,
    device = "png", # Especifica el dispositivo PNG
    width = save_width,
    height = save_height,
    units = save_units,
    dpi = save_dpi, # ¡Importante para la calidad del PNG! (usa 300 o 600)
    bg = "white" # Opcional: definir color de fondo si hay transparencia
  )

ggsave(
    filename = "./graficos_output/grafico_region_alta_calidad.png",
    plot = grafico_region,
    device = "png", # Especifica el dispositivo PNG
    width = save_width,
    height = save_height,
    units = save_units,
    dpi = save_dpi, # ¡Importante para la calidad del PNG! (usa 300 o 600)
    bg = "white" # Opcional: definir color de fondo si hay transparencia
  )

cat("\n¡Proceso de guardado completado!\n")
cat("Los gráficos se guardaron en la carpeta:", fs::path_abs(output_dir), "\n")
```
